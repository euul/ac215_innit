---
- name: "Create Kubernetes Cluster and deploy multiple containers"
  hosts: localhost
  gather_facts: false

  vars:
    cluster_name: "load-balance-test"
    machine_type: "n2d-standard-2"
    machine_disk_size: 30
    initial_node_count: 2

  tasks:
  - name: "Create a GKE cluster"
    google.cloud.gcp_container_cluster:
      name: "{{ cluster_name }}"
      initial_node_count: "{{ initial_node_count }}"
      location: "{{ gcp_zone }}"
      project: "{{ gcp_project }}"
      release_channel:
        channel: "UNSPECIFIED"
      ip_allocation_policy:
        use_ip_aliases: "yes"
      auth_kind: "{{ gcp_auth_kind }}"
      service_account_file: "{{ gcp_service_account_file }}"
      state: "{{ cluster_state }}"
    register: cluster

  - name: "Create a Node Pool"
    google.cloud.gcp_container_node_pool:
      name: "default-pool"
      cluster: "{{ cluster }}"
      location: "{{ gcp_zone }}"
      project: "{{ gcp_project }}"
      initial_node_count: "{{ initial_node_count }}"
      config:
        machine_type: "{{ machine_type }}"
        image_type: "cos_containerd"
        disk_size_gb: "{{ machine_disk_size }}"
        oauth_scopes:
          - "https://www.googleapis.com/auth/devstorage.read_only"
          - "https://www.googleapis.com/auth/logging.write"
          - "https://www.googleapis.com/auth/monitoring"
          - "https://www.googleapis.com/auth/servicecontrol"
          - "https://www.googleapis.com/auth/service.management.readonly"
          - "https://www.googleapis.com/auth/trace.append"
      autoscaling:
        enabled: "yes"
        min_node_count: "1"
        max_node_count: "{{ initial_node_count }}"
      management:
        auto_repair: "yes"
        auto_upgrade: "yes"
      auth_kind: "{{ gcp_auth_kind }}"
      service_account_file: "{{ gcp_service_account_file }}"
      state: "{{ cluster_state }}"

  - name: "Connect to cluster (update kubeconfig)"
    shell: "gcloud container clusters get-credentials {{ cluster.name }} --zone {{ gcp_zone }} --project {{ gcp_project }}"
    when: cluster_state == "present"

  - name: "Create Namespace"
    k8s:
      name: "{{ cluster_name }}-namespace"
      api_version: v1
      kind: Namespace
      state: present
    when: cluster_state == "present"

  - name: "Get docker tag"
    shell: "cat .docker-tag"
    register: tag
    when: cluster_state == "present"

  - name: "Print docker tag"
    debug:
      var: tag.stdout
    when: cluster_state == "present"

  - name: "Create Deployment for API Service (initial)"
    k8s:
      state: present
      definition:
        apiVersion: apps/v1
        kind: Deployment
        metadata:
          name: api-service
          namespace: "{{ cluster_name }}-namespace"
        spec:
          replicas: 1
          selector:
            matchLabels:
              app: api-service
          template:
            metadata:
              labels:
                app: api-service
            spec:
              containers:
              - name: api-service
                image: "gcr.io/{{ gcp_project }}/test-api-service:{{ tag.stdout }}"
                ports:
                - containerPort: 8000
                env:
                - name: GOOGLE_APPLICATION_CREDENTIALS
                  value: "/secrets/deployment.json"
                - name: FRONTEND_ORIGIN
                  value: "http://localhost:3000"  # Default value

  - name: "Create Service for API Service"
    k8s:
      state: present
      definition:
        apiVersion: v1
        kind: Service
        metadata:
          name: api-service
          namespace: "{{ cluster_name }}-namespace"
        spec:
          type: LoadBalancer
          ports:
          - port: 5000
            targetPort: 8000
          selector:
            app: api-service
            
  - name: "Get External IP for API Service"
    shell: kubectl get svc api-service -n "{{ cluster_name }}-namespace" -o jsonpath='{.status.loadBalancer.ingress[0].ip}'
    register: api_service_ip
    retries: 10
    delay: 10

  - name: "Create Deployment for Frontend"
    k8s:
      state: present
      definition:
        apiVersion: apps/v1
        kind: Deployment
        metadata:
          name: frontend
          namespace: "{{ cluster_name }}-namespace"
        spec:
          replicas: 1
          selector:
            matchLabels:
              app: frontend
          template:
            metadata:
              labels:
                app: frontend
            spec:
              containers:
              - name: frontend
                image: "gcr.io/{{ gcp_project }}/test-frontend:{{ tag.stdout }}"
                ports:
                - containerPort: 3000
                env:
                - name: REACT_APP_BACKEND_URL
                  value: "http://{{ api_service_ip.stdout }}:5000"


  - name: "Create Service for Frontend"
    k8s:
      state: present
      definition:
        apiVersion: v1
        kind: Service
        metadata:
          name: frontend
          namespace: "{{ cluster_name }}-namespace"
        spec:
          type: LoadBalancer
          ports:
          - port: 3000
            targetPort: 3000
          selector:
            app: frontend

  - name: "Get External IP for Frontend Service"
    shell: kubectl get svc frontend -n "{{ cluster_name }}-namespace" -o jsonpath='{.status.loadBalancer.ingress[0].ip}'
    register: frontend_service_ip
    retries: 10
    delay: 10

  - name: "Update API Service with Frontend Origin"
    shell: >
      kubectl set env deployment/api-service FRONTEND_ORIGIN=http://{{ frontend_service_ip.stdout }}:3000
      -n "{{ cluster_name }}-namespace"
